<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Labyrinth mit Task und Auto</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #111;
      width: 100%;
      height: 100%;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    #controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 20px;
      padding: 10px;
      background: #222;
      color: white;
    }
    #controls > div {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    select, label, button {
      padding: 10px;
      font-size: 16px;
      color: white;
      background: #333;
      border: none;
    }
    input[type="checkbox"] {
      transform: scale(1.5);
      margin-left: 10px;
    }
    .cone-display {
      font-size: 16px;
    }
    canvas {
      flex: 1;
      display: block;
      background: #fff;
    }
  </style>
</head>
<body>
  <div id="controls">
    <div>
      <label>Typ:</label>
      <select id="obstacleSize">
        <option value="40">40x40</option>
        <option value="80">80x80</option>
        <option value="120">120x120</option>
        <option value="task">Task (grüner Punkt)</option>
      </select>
    </div>
    <div>
      <label>Entfernen</label>
      <input type="checkbox" id="removeMode">
    </div>
    <button id="generateMaze">Labyrinth generieren</button>
    <div class="cone-display">Rot: <span id="redLength">0</span> px</div>
    <div class="cone-display">Grün: <span id="greenLength">0</span> px</div>
    <div class="cone-display">Blau Links 1: <span id="blueLeft1">0</span> px</div>
    <div class="cone-display">Blau Links 2: <span id="blueLeft2">0</span> px</div>
    <div class="cone-display">Blau Rechts 1: <span id="blueRight1">0</span> px</div>
    <div class="cone-display">Blau Rechts 2: <span id="blueRight2">0</span> px</div>
    <div class="cone-display">Blau Hinten: <span id="blueBack">0</span> px</div>
    <label>Size:
      <input id="gridWidth" type="number" value="20" min="1" style="width:60px"> x
      <input id="gridHeight" type="number" value="15" min="1" style="width:60px">
    </label>
    <button id="setSizeBtn">Set Size</button>
    <input type="text" id="mapName" placeholder="Map name">
    <button id="saveMapDb">Save Map</button>
    <select id="mapSelect"></select>
    <button id="fetchMaps">Karten abrufen</button>
    <button id="loadMapDb">Karte laden</button>
    <input type="text" id="renameMapName" placeholder="Neuer Name">
    <button id="renameMapBtn">Rename</button>
    <button id="deleteMapBtn">Delete</button>
    <button id="saveMap">Download Map</button>
    <button id="loadMapBtn">Load Map</button>
    <input type="file" id="loadMap" style="display:none" accept="application/json">
  </div>
  <canvas id="canvas"></canvas>

  <script type="module">
    import { Car } from './car.js'
    import { Obstacle } from './obstacle.js'
    import { GameMap } from './map.js'

    const canvas = document.getElementById('canvas')
    const ctx = canvas.getContext('2d')
    const dropdown = document.getElementById('obstacleSize')
    const removeCheckbox = document.getElementById('removeMode')
    const generateMazeBtn = document.getElementById('generateMaze')
    const redEl = document.getElementById('redLength')
    const greenEl = document.getElementById('greenLength')
    const blueLeft1El = document.getElementById('blueLeft1')
    const blueLeft2El = document.getElementById('blueLeft2')
    const blueRight1El = document.getElementById('blueRight1')
    const blueRight2El = document.getElementById('blueRight2')
    const blueBackEl = document.getElementById('blueBack')

    let gameMap = new GameMap(20, 15)
    let CELL_SIZE = gameMap.cellSize
    let obstacles = gameMap.obstacles
    let previewSize = parseInt(dropdown.value)
    let isDragging = false
    let dragX = 0
    let dragY = 0
    let taskMarker = gameMap.task

    const carImage = new Image()
    carImage.src = 'extracted_foreground.png'
    const car = new Car(ctx, carImage, 0.5, 0, obstacles, { startX: 100, startY: 100 })

    function resizeCanvas() {
      canvas.width = gameMap.cols * CELL_SIZE
      canvas.height = gameMap.rows * CELL_SIZE
    }

    window.addEventListener('resize', resizeCanvas)

    dropdown.addEventListener('change', () => {
      const val = dropdown.value
      previewSize = parseInt(val) || CELL_SIZE
    })

    canvas.addEventListener('mousedown', e => {
      const rect = canvas.getBoundingClientRect()
      dragX = Math.floor((e.clientX - rect.left) / CELL_SIZE) * CELL_SIZE
      dragY = Math.floor((e.clientY - rect.top) / CELL_SIZE) * CELL_SIZE
      isDragging = true
    })

    canvas.addEventListener('mouseup', () => {
      if (!isDragging) return
      const selected = dropdown.value

      if (removeCheckbox.checked) {
        if (taskMarker &&
            dragX <= taskMarker.x && dragX + CELL_SIZE >= taskMarker.x &&
            dragY <= taskMarker.y && dragY + CELL_SIZE >= taskMarker.y) {
          taskMarker = null
          gameMap.task = null
        }

        const i = obstacles.findIndex(o => o.x === dragX && o.y === dragY)
        if (i !== -1) obstacles.splice(i, 1)

      } else if (selected === 'task') {
        taskMarker = { x: dragX + CELL_SIZE/2, y: dragY + CELL_SIZE/2, radius: Math.floor(CELL_SIZE/3) }
        gameMap.task = taskMarker
      } else {
        obstacles.push(new Obstacle(dragX, dragY, previewSize))
      }

      isDragging = false
    })

    canvas.addEventListener('mousemove', e => {
      if (!isDragging) return
      const rect = canvas.getBoundingClientRect()
      dragX = Math.floor((e.clientX - rect.left) / CELL_SIZE) * CELL_SIZE
      dragY = Math.floor((e.clientY - rect.top) / CELL_SIZE) * CELL_SIZE
    })

    function generateBorder() {
      const cols = gameMap.cols
      const rows = gameMap.rows
      for (let x = 0; x < cols; x++) {
        for (const y of [0, rows - 1]) {
          obstacles.push(new Obstacle(x*CELL_SIZE, y*CELL_SIZE, CELL_SIZE))
        }
      }
      for (let y = 1; y < rows-1; y++) {
        for (const x of [0, cols-1]) {
          obstacles.push(new Obstacle(x*CELL_SIZE, y*CELL_SIZE, CELL_SIZE))
        }
      }
    }

    function generateMaze() {
      obstacles.length = 0
      const cols = gameMap.cols
      const rows = gameMap.rows
      const minPassage = 4, maxPassage = 6
      let y = 1
      while (y < rows - 1) {
        const h = Math.floor(Math.random()*(maxPassage-minPassage+1))+minPassage
        for (let x =1; x<cols-1; x++) if (Math.random()<0.3)
          obstacles.push(new Obstacle(x*CELL_SIZE, y*CELL_SIZE, CELL_SIZE))
        y += h
        if (y < rows-1) {
          const gapStart = Math.floor(Math.random()*(cols-10))+5
          const gapWidth = Math.floor(Math.random()*3)+4
          for (let x=1; x<cols-1; x++) if (x<gapStart||x>gapStart+gapWidth)
            obstacles.push(new Obstacle(x*CELL_SIZE, y*CELL_SIZE, CELL_SIZE))
          y++
        }
      }
      generateBorder()
    }

    generateMazeBtn.addEventListener('click', generateMaze)

    document.getElementById('saveMap').addEventListener('click', saveMap)
    document.getElementById('saveMapDb').addEventListener('click', uploadMap)
    document.getElementById('loadMapBtn').addEventListener('click', () => document.getElementById('loadMap').click())
    document.getElementById('loadMap').addEventListener('change', loadMap)
    document.getElementById('loadMapDb').addEventListener('click', loadMapFromDb)
    document.getElementById('fetchMaps').addEventListener('click', fetchAvailableMaps)
    document.getElementById('renameMapBtn').addEventListener('click', renameMap)
    document.getElementById('deleteMapBtn').addEventListener('click', deleteMap)
    document.getElementById('setSizeBtn').addEventListener('click', resizeMap)

    function drawGrid() {
      ctx.strokeStyle = '#ddd'
      for (let x=0; x<=canvas.width; x+=CELL_SIZE) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke() }
      for (let y=0; y<=canvas.height; y+=CELL_SIZE) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke() }
    }

    function loop() {
      ctx.clearRect(0,0,canvas.width,canvas.height)
      drawGrid()
      for (const o of obstacles) o.draw(ctx)
      if (taskMarker) {
        ctx.fillStyle='green'; ctx.beginPath(); ctx.arc(taskMarker.x, taskMarker.y, taskMarker.radius,0,Math.PI*2); ctx.fill()
      }
      if (isDragging && dropdown.value!=='task' && !removeCheckbox.checked) {
        ctx.strokeStyle='red'; ctx.lineWidth=2; ctx.strokeRect(dragX, dragY, previewSize, previewSize)
      }
      car.update(canvas.width, canvas.height)

      redEl.textContent = Math.round(car.redConeLength)
      greenEl.textContent = Math.round(car.greenConeLength)
      const bl1 = car.drawKegel(65,7,150,-Math.PI/2,'blue',8)
      const bl2 = car.drawKegel(72,7,150,-Math.PI/2,'blue',8)
      const br1 = car.drawKegel(91,7,150,-Math.PI/2,'blue',8)
      const br2 = car.drawKegel(97,7,150,-Math.PI/2,'blue',8)
      const bb  = car.drawKegel(143,37,150,0,'blue',8)
      blueLeft1El.textContent = Math.round(bl1)
      blueLeft2El.textContent = Math.round(bl2)
      blueRight1El.textContent = Math.round(br1)
      blueRight2El.textContent = Math.round(br2)
      blueBackEl.textContent = Math.round(bb)

      requestAnimationFrame(loop)
    }

    function getCurrentMapData() {
      return {
        cols: gameMap.cols,
        rows: gameMap.rows,
        cellSize: gameMap.cellSize,
        obstacles: obstacles.map(o => ({x:o.x, y:o.y, size:o.size})),
        task: taskMarker
      }
    }

    function saveMap() {
      const data = getCurrentMapData()
      const blob = new Blob([JSON.stringify(data)], {type: 'application/json'})
      const link = document.createElement('a')
      link.href = URL.createObjectURL(blob)
      link.download = 'map.json'
      link.click()
    }

    function getDefaultMapName() {
      const d = new Date()
      return d.toISOString().replace(/[:.]/g, '-')
    }

    function uploadMap() {
      let name = document.getElementById('mapName').value.trim()
      if (!name) {
        name = getDefaultMapName()
        document.getElementById('mapName').value = name
      }
      const data = getCurrentMapData()
      fetch('http://127.0.0.1:5000/api/maps', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name: name, map: data })
      }).then(res => {
        if (res.ok) alert('Gespeichert')
        else res.text().then(t => alert('Fehler beim Speichern:\n' + t))
      }).catch(err => {
        alert('Netzwerkfehler:\n' + err)
      })
    }

    function loadMap(e) {
      const file = e.target.files[0]
      if (!file) return
      const reader = new FileReader()
      reader.onload = () => {
        const obj = JSON.parse(reader.result)
        gameMap = GameMap.fromJSON(obj)
        CELL_SIZE = gameMap.cellSize
        obstacles = gameMap.obstacles
        taskMarker = gameMap.task
        car.objects = obstacles
        document.getElementById('gridWidth').value = gameMap.cols
        document.getElementById('gridHeight').value = gameMap.rows
        resizeCanvas()
      }
      reader.readAsText(file)
    }

    function fetchAvailableMaps() {
      fetch('http://127.0.0.1:5000/api/maps')
        .then(res => res.json())
        .then(data => {
          const select = document.getElementById('mapSelect')
          select.innerHTML = ''
          data.forEach(m => {
            const opt = document.createElement('option')
            opt.value = m.id
            opt.textContent = m.name + ' (' + m.created_at + ')'
            select.appendChild(opt)
          })
        })
    }

    function loadMapFromDb() {
      const mapId = document.getElementById('mapSelect').value
      if (!mapId) { alert('Keine Map ausgewählt'); return }
      fetch(`http://127.0.0.1:5000/api/maps/${mapId}`)
        .then(res => res.json())
        .then(obj => {
          gameMap = GameMap.fromJSON(obj)
          CELL_SIZE = gameMap.cellSize
          obstacles = gameMap.obstacles
          taskMarker = gameMap.task
          car.objects = obstacles
          document.getElementById('gridWidth').value = gameMap.cols
          document.getElementById('gridHeight').value = gameMap.rows
          resizeCanvas()
        })
    }

    function renameMap() {
      const mapId = document.getElementById('mapSelect').value
      const newName = document.getElementById('renameMapName').value.trim()
      if (!mapId) { alert('Keine Map ausgewählt'); return }
      if (!newName) { alert('Neuer Name fehlt'); return }
      fetch(`http://127.0.0.1:5000/api/maps/${mapId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name: newName })
      }).then(res => {
        if (res.ok) { fetchAvailableMaps(); alert('Umbenannt') }
        else res.text().then(t => alert('Fehler beim Umbenennen:\n' + t))
      })
    }

    function deleteMap() {
      const mapId = document.getElementById('mapSelect').value
      if (!mapId) { alert('Keine Map ausgewählt'); return }
      if (!confirm('Map löschen?')) return
      fetch(`http://127.0.0.1:5000/api/maps/${mapId}`, { method: 'DELETE' })
        .then(res => {
          if (res.ok) { fetchAvailableMaps(); alert('Gelöscht') }
          else res.text().then(t => alert('Fehler beim Löschen:\n' + t))
        })
    }

    function resizeMap() {
      const w = parseInt(document.getElementById('gridWidth').value, 10)
      const h = parseInt(document.getElementById('gridHeight').value, 10)
      if (isNaN(w) || isNaN(h) || w <= 0 || h <= 0) { alert('Invalid size'); return }
      gameMap = new GameMap(w, h, CELL_SIZE)
      obstacles = gameMap.obstacles
      taskMarker = null
      car.objects = obstacles
      resizeCanvas()
      generateBorder()
    }

    carImage.onload = () => { resizeCanvas(); fetchAvailableMaps(); loop() }
  </script>
</body>
</html>
