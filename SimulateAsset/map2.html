<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Labyrinth mit Task und Auto</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #111;
      width: 100%;
      height: 100%;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    #controls {
      display: flex;
      justify-content: center;
      gap: 20px;
      padding: 10px;
      background: #222;
      color: white;
    }
    #controls > div {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    select, label, button {
      padding: 10px;
      font-size: 16px;
      color: white;
      background: #333;
      border: none;
    }
    input[type="checkbox"] {
      transform: scale(1.5);
      margin-left: 10px;
    }
    .cone-display {
      font-size: 16px;
    }
    canvas {
      flex: 1;
      display: block;
      background: #fff;
    }
  </style>
</head>
<body>
  <div id="controls">
    <div>
      <label>Typ:</label>
      <select id="obstacleSize">
        <option value="40">40x40</option>
        <option value="80">80x80</option>
        <option value="120">120x120</option>
        <option value="task">Task (grüner Punkt)</option>
      </select>
    </div>
    <div>
      <label>Entfernen</label>
      <input type="checkbox" id="removeMode">
    </div>
    <button id="generateMaze">Labyrinth generieren</button>
    <div class="cone-display">Rot: <span id="redLength">0</span> px</div>
    <div class="cone-display">Grün: <span id="greenLength">0</span> px</div>
    <div class="cone-display">Blau Links 1: <span id="blueLeft1">0</span> px</div>
    <div class="cone-display">Blau Links 2: <span id="blueLeft2">0</span> px</div>
    <div class="cone-display">Blau Rechts 1: <span id="blueRight1">0</span> px</div>
    <div class="cone-display">Blau Rechts 2: <span id="blueRight2">0</span> px</div>
    <div class="cone-display">Blau Hinten: <span id="blueBack">0</span> px</div>
  </div>
  <canvas id="canvas"></canvas>

  <script type="module">
    import { Car } from './car.js'
    import { Obstacle } from './obstacle.js'

    const canvas = document.getElementById('canvas')
    const ctx = canvas.getContext('2d')
    const dropdown = document.getElementById('obstacleSize')
    const removeCheckbox = document.getElementById('removeMode')
    const generateMazeBtn = document.getElementById('generateMaze')
    const redEl = document.getElementById('redLength')
    const greenEl = document.getElementById('greenLength')
    const blueLeft1El = document.getElementById('blueLeft1')
    const blueLeft2El = document.getElementById('blueLeft2')
    const blueRight1El = document.getElementById('blueRight1')
    const blueRight2El = document.getElementById('blueRight2')
    const blueBackEl = document.getElementById('blueBack')

    let CELL_SIZE = 40
    const obstacles = []
    let previewSize = parseInt(dropdown.value)
    let isDragging = false
    let dragX = 0
    let dragY = 0
    let taskMarker = null

    const carImage = new Image()
    carImage.src = 'extracted_foreground.png'
    const car = new Car(ctx, carImage, 0.5, 0, obstacles, { startX: 100, startY: 100 })

    function resizeCanvas() {
      canvas.width = window.innerWidth
      canvas.height = window.innerHeight - document.getElementById('controls').offsetHeight
      generateBorder()
    }

    window.addEventListener('resize', resizeCanvas)

    dropdown.addEventListener('change', () => {
      const val = dropdown.value
      previewSize = parseInt(val) || CELL_SIZE
    })

    canvas.addEventListener('mousedown', e => {
      const rect = canvas.getBoundingClientRect()
      dragX = Math.floor((e.clientX - rect.left) / CELL_SIZE) * CELL_SIZE
      dragY = Math.floor((e.clientY - rect.top) / CELL_SIZE) * CELL_SIZE
      isDragging = true
    })

    canvas.addEventListener('mouseup', () => {
      if (!isDragging) return
      const selected = dropdown.value

      if (removeCheckbox.checked) {
        if (taskMarker &&
            dragX <= taskMarker.x && dragX + CELL_SIZE >= taskMarker.x &&
            dragY <= taskMarker.y && dragY + CELL_SIZE >= taskMarker.y) {
          taskMarker = null
        }

        const i = obstacles.findIndex(o => o.x === dragX && o.y === dragY)
        if (i !== -1) obstacles.splice(i, 1)

      } else if (selected === "task") {
        taskMarker = { x: dragX + CELL_SIZE/2, y: dragY + CELL_SIZE/2, radius: Math.floor(CELL_SIZE/3) }
      } else {
        obstacles.push(new Obstacle(dragX, dragY, previewSize))
      }

      isDragging = false
    })

    canvas.addEventListener('mousemove', e => {
      if (!isDragging) return
      const rect = canvas.getBoundingClientRect()
      dragX = Math.floor((e.clientX - rect.left) / CELL_SIZE) * CELL_SIZE
      dragY = Math.floor((e.clientY - rect.top) / CELL_SIZE) * CELL_SIZE
    })

    function generateBorder() {
      const cols = Math.floor(canvas.width / CELL_SIZE)
      const rows = Math.floor(canvas.height / CELL_SIZE)
      for (let x = 0; x < cols; x++) {
        for (const y of [0, rows - 1]) {
          obstacles.push(new Obstacle(x*CELL_SIZE, y*CELL_SIZE, CELL_SIZE))
        }
      }
      for (let y = 1; y < rows-1; y++) {
        for (const x of [0, cols-1]) {
          obstacles.push(new Obstacle(x*CELL_SIZE, y*CELL_SIZE, CELL_SIZE))
        }
      }
    }

    function generateMaze() {
      obstacles.length = 0
      const cols = Math.floor(canvas.width / CELL_SIZE)
      const rows = Math.floor(canvas.height / CELL_SIZE)
      const minPassage = 4, maxPassage = 6
      let y = 1
      while (y < rows - 1) {
        const h = Math.floor(Math.random()*(maxPassage-minPassage+1))+minPassage
        for (let x =1; x<cols-1; x++) if (Math.random()<0.3)
          obstacles.push(new Obstacle(x*CELL_SIZE, y*CELL_SIZE, CELL_SIZE))
        y += h
        if (y < rows-1) {
          const gapStart = Math.floor(Math.random()*(cols-10))+5
          const gapWidth = Math.floor(Math.random()*3)+4
          for (let x=1; x<cols-1; x++) if (x<gapStart||x>gapStart+gapWidth)
            obstacles.push(new Obstacle(x*CELL_SIZE, y*CELL_SIZE, CELL_SIZE))
          y++
        }
      }
      generateBorder()
    }

    generateMazeBtn.addEventListener('click', generateMaze)

    function drawGrid() {
      ctx.strokeStyle = '#ddd'
      for (let x=0; x<=canvas.width; x+=CELL_SIZE) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke() }
      for (let y=0; y<=canvas.height; y+=CELL_SIZE) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke() }
    }

    function loop() {
      ctx.clearRect(0,0,canvas.width,canvas.height)
      drawGrid()
      for (const o of obstacles) o.draw(ctx)
      if (taskMarker) {
        ctx.fillStyle='green'; ctx.beginPath(); ctx.arc(taskMarker.x, taskMarker.y, taskMarker.radius,0,Math.PI*2); ctx.fill()
      }
      if (isDragging && dropdown.value!=='task' && !removeCheckbox.checked) {
        ctx.strokeStyle='red'; ctx.lineWidth=2; ctx.strokeRect(dragX, dragY, previewSize, previewSize)
      }
      car.update(canvas.width, canvas.height)

      redEl.textContent = Math.round(car.redConeLength)
      greenEl.textContent = Math.round(car.greenConeLength)
      // Blau einzeln
      const bl1 = car.drawKegel(65,7,150,-Math.PI/2,'blue',8)
      const bl2 = car.drawKegel(72,7,150,-Math.PI/2,'blue',8)
      const br1 = car.drawKegel(91,7,150,-Math.PI/2,'blue',8)
      const br2 = car.drawKegel(97,7,150,-Math.PI/2,'blue',8)
      const bb  = car.drawKegel(143,37,150,0,'blue',8)
      blueLeft1El.textContent = Math.round(bl1)
      blueLeft2El.textContent = Math.round(bl2)
      blueRight1El.textContent = Math.round(br1)
      blueRight2El.textContent = Math.round(br2)
      blueBackEl.textContent = Math.round(bb)

      requestAnimationFrame(loop)
    }

    carImage.onload = () => { resizeCanvas(); loop() }
  </script>
</body>
</html>
